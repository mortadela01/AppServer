Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\api\output.txt
from django.contrib import admin  # Register your models here.  # from django.apps import AppConfig   # class ApiConfig(AppConfig): #     default_auto_field = 'django.db.models.BigAutoField' #     name = 'api'  from django.apps import AppConfig  class ApiConfig(AppConfig):     default_auto_field = 'django.db.models.BigAutoField'     name = 'api'      def ready(self):         import oauth2_provider.views.base as base_views         original_post = base_views.TokenView.post          def debug_post(self, request, *args, **kwargs):             print("=== TokenView POST ===")             print("request.POST:", request.POST)             print("request.body:", request.body.decode('utf-8'))             result = original_post(self, request, *args, **kwargs)             print("=== TokenView POST result status:", result.status_code)             return result          base_views.TokenView.post = debug_post  class LogRequestBodyMiddleware:     def __init__(self, get_response):         self.get_response = get_response      def __call__(self, request):         if request.path == '/o/token/' and request.method == 'POST':             print(f"Body POST /o/token/: {request.body.decode('utf-8')}")         return self.get_response(request)  class TokenDebugMiddleware:     def __init__(self, get_response):         self.get_response = get_response      def __call__(self, request):         if request.path == '/o/token/' and request.method == 'POST':             print("=== /o/token/ REQUEST START ===")             print("Headers:", dict(request.headers))             print("Body:", request.body.decode('utf-8'))             print("POST data:", request.POST)             print("=== /o/token/ REQUEST END ===")         return self.get_response(request)      # Middleware para capturar y validar el token Bearer from oauth2_provider.models import AccessToken from rest_framework.exceptions import AuthenticationFailed  class TokenValidationMiddleware:     def __init__(self, get_response):         self.get_response = get_response      def __call__(self, request):         # Verificamos si la solicitud tiene el encabezado Authorization         auth_header = request.headers.get('Authorization', None)         if auth_header:             # Extraemos el token Bearer             try:                 token_type, token = auth_header.split(' ')                 if token_type.lower() != 'bearer':                     raise AuthenticationFailed('Invalid token type')                                  # Ahora verificamos si el token Bearer es válido                 try:                     access_token = AccessToken.objects.get(token=token)                 except AccessToken.DoesNotExist:                     raise AuthenticationFailed('Invalid or expired token')                  # Si el token es válido, lo añadimos al request                 request.user = access_token.user                 return self.get_response(request)                          except ValueError:                 raise AuthenticationFailed('Invalid Authorization header format')          # Si no hay token o no es Bearer, rechazamos la solicitud         raise AuthenticationFailed('Authorization token missing or invalid')   from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager, Group, Permission from django.db import models  class UserManager(BaseUserManager):     def create_user(self, email, password=None, **extra_fields):         if not email:             raise ValueError('El email es obligatorio')         email = self.normalize_email(email)         user = self.model(email=email, **extra_fields)         user.set_password(password)         user.save(using=self._db)         return user      def create_superuser(self, email, password=None, **extra_fields):         extra_fields.setdefault('is_staff', True)         extra_fields.setdefault('is_superuser', True)         extra_fields.setdefault('is_active', True)          if not extra_fields.get('is_staff'):             raise ValueError('Superuser debe tener is_staff=True.')         if not extra_fields.get('is_superuser'):             raise ValueError('Superuser debe tener is_superuser=True.')          return self.create_user(email, password, **extra_fields)  class User(AbstractBaseUser, PermissionsMixin):     id_user = models.BigAutoField(primary_key=True)     name = models.CharField(max_length=100, blank=True)     email = models.EmailField(unique=True)     password = models.CharField(max_length=250)     is_staff = models.BooleanField(default=False)     is_active = models.BooleanField(default=True)     last_login = models.DateTimeField(blank=True, null=True)      groups = models.ManyToManyField(         Group,         related_name='api_user_set',         blank=True,         help_text='Los grupos a los que pertenece el usuario.',         verbose_name='groups',     )     user_permissions = models.ManyToManyField(         Permission,         related_name='api_user_set',         blank=True,         help_text='Permisos específicos para este usuario.',         verbose_name='user permissions',     )      objects = UserManager()      USERNAME_FIELD = 'email'     REQUIRED_FIELDS = []      class Meta:         db_table = 'TBL_USER'         managed = False      def __str__(self):         return self.email  class Deceased(models.Model):     id_deceased = models.BigAutoField(primary_key=True)     name = models.CharField(max_length=100)     date_birth = models.DateField(null=True, blank=True)     date_death = models.DateField(null=True, blank=True)     description = models.TextField(null=True, blank=True)     burial_place = models.CharField(max_length=100, null=True, blank=True)     visualization_state = models.BooleanField(default=True)     visualization_code = models.CharField(max_length=100, null=True, blank=True)      class Meta:         db_table = 'TBL_DECEASED'         managed = False      def __str__(self):         return self.name   class Video(models.Model):     id_video = models.BigAutoField(primary_key=True)     video_link = models.CharField(max_length=1000)     event_title = models.CharField(max_length=100)     description = models.CharField(max_length=100)      class Meta:         db_table = 'TBL_VIDEO'         managed = False  class VideoMetadata(models.Model):     id_metadata = models.BigAutoField(primary_key=True)     date_created = models.DateTimeField()     coordinates = models.CharField(max_length=100)      class Meta:         db_table = 'TBL_VIDEO_METADATA'         managed = False  class DeceasedVideo(models.Model):     id_deceased_video = models.BigAutoField(primary_key=True)     id_video = models.ForeignKey(Video, on_delete=models.CASCADE, db_column='id_video')     id_deceased = models.ForeignKey(Deceased, on_delete=models.CASCADE, db_column='id_deceased')     id_metadata = models.ForeignKey(VideoMetadata, on_delete=models.CASCADE, db_column='id_metadata')     video_link = models.CharField(max_length=1000)      class Meta:         db_table = 'TBL_DECEASED_VIDEO'         managed = False         unique_together = (('id_deceased', 'id_metadata'),)  class Image(models.Model):     id_image = models.BigAutoField(primary_key=True)     image_link = models.CharField(max_length=1000)     event_title = models.CharField(max_length=100)     description = models.CharField(max_length=100)      class Meta:         db_table = 'TBL_IMAGE'         managed = False  class ImageMetadata(models.Model):     id_metadata = models.BigAutoField(primary_key=True)     date_created = models.DateTimeField()     coordinates = models.CharField(max_length=100)      class Meta:         db_table = 'TBL_IMAGE_METADATA'         managed = False  class DeceasedImage(models.Model):     id_deceased_image = models.BigAutoField(primary_key=True)     id_image = models.ForeignKey(Image, on_delete=models.CASCADE, db_column='id_image')     id_deceased = models.ForeignKey(Deceased, on_delete=models.CASCADE, db_column='id_deceased')     id_metadata = models.ForeignKey(ImageMetadata, on_delete=models.CASCADE, db_column='id_metadata')     image_link = models.CharField(max_length=1000)      class Meta:         db_table = 'TBL_DECEASED_IMAGE'         managed = False         unique_together = (('id_image', 'id_deceased', 'id_metadata'),)  class RelationshipType(models.Model):     relationship = models.CharField(primary_key=True, max_length=100)      class Meta:         db_table = 'TBL_RELATIONSHIP_TYPE'         managed = False  class Relation(models.Model):     id_relation = models.BigAutoField(primary_key=True)     id_deceased = models.ForeignKey(Deceased, on_delete=models.CASCADE, related_name='child', db_column='id_deceased')     id_parent = models.ForeignKey(Deceased, on_delete=models.CASCADE, related_name='parent', db_column='id_parent')     relationship = models.ForeignKey(RelationshipType, on_delete=models.CASCADE, db_column='relationship')      class Meta:         db_table = 'TBL_RELATION'         managed = False         unique_together = (('id_deceased', 'id_parent'),)  class UserDeceased(models.Model):     id_user_deceased = models.BigAutoField(primary_key=True)     id_user = models.ForeignKey(User, on_delete=models.CASCADE, db_column='id_user')     id_deceased = models.ForeignKey(Deceased, on_delete=models.CASCADE, db_column='id_deceased')     date_relation = models.DateTimeField()     has_permission = models.BooleanField()      class Meta:         db_table = 'TBL_USER_DECEASED'         managed = False         unique_together = (('id_user', 'id_deceased'),)  class Request(models.Model):     id_request = models.BigAutoField(primary_key=True)     id_issuer = models.ForeignKey(User, on_delete=models.CASCADE, related_name='issued_requests', db_column='id_issuer')     id_receiver = models.ForeignKey(User, on_delete=models.CASCADE, related_name='received_requests', db_column='id_receiver')     id_deceased = models.ForeignKey(Deceased, on_delete=models.CASCADE, db_column='id_deceased')     creation_date = models.DateField()     request_type = models.CharField(max_length=50)     request_status = models.CharField(max_length=50)      class Meta:         db_table = 'TBL_REQUEST'         managed = False  class Notification(models.Model):     id_notification = models.BigAutoField(primary_key=True)     id_sender = models.ForeignKey(User, on_delete=models.CASCADE, related_name='sent_notifications', db_column='id_sender')     id_receiver = models.ForeignKey(User, on_delete=models.CASCADE, related_name='received_notifications', db_column='id_receiver')     message = models.CharField(max_length=1000)     is_read = models.BooleanField(default=False)     creation_date = models.DateTimeField()      class Meta:         db_table = 'TBL_NOTIFICATION'         managed = False  class QR(models.Model):     id_qr = models.BigAutoField(primary_key=True)     id_user = models.ForeignKey(User, on_delete=models.CASCADE, db_column='id_user')     qr_code = models.BigIntegerField(unique=True)     visualization_status = models.CharField(max_length=50)     generation_date = models.DateTimeField()      class Meta:         db_table = 'TBL_QR'         managed = False  from oauth2_provider.oauth2_validators import OAuth2Validator from django.contrib.auth import get_user_model from django.contrib.auth import authenticate  User = get_user_model()  class MyOAuth2Validator(OAuth2Validator):     def validate_user(self, username, password, client, request, *args, **kwargs):         # Aquí buscamos el usuario por email (que es username para ti)         try:             user = User.objects.get(email=username)         except User.DoesNotExist:             return False                  # Intentamos autenticar con email y password         authenticated_user = authenticate(username=user.email, password=password)         if authenticated_user is not None:             request.user = authenticated_user             return True         return False  from rest_framework import serializers from .models import * from .models import Deceased import datetime  # class UserSerializer(serializers.ModelSerializer): #     class Meta: #         model = User #         fields = '__all__'  # No incluyas la contraseña en el serializer (sí la incluyo jaja)  class UserSerializer(serializers.ModelSerializer):     password = serializers.CharField(write_only=True)      class Meta:         model = User         fields = ['id_user', 'email', 'name', 'password']      def create(self, validated_data):         password = validated_data.pop('password')         user = User(**validated_data)         user.set_password(password)  # aquí se hace el hash         user.save()         return user          def update(self, instance, validated_data):         password = validated_data.pop('password', None)         for attr, value in validated_data.items():             setattr(instance, attr, value)         if password:             instance.set_password(password)         instance.save()         return instance  class DateOnlyField(serializers.Field):     def to_representation(self, value):         if isinstance(value, datetime.datetime):             return value.date().isoformat()         elif isinstance(value, datetime.date):             return value.isoformat()         return None      def to_internal_value(self, data):         # Asumimos que data es string en formato 'YYYY-MM-DD'         try:             return datetime.datetime.strptime(data, '%Y-%m-%d').date()         except (ValueError, TypeError):             raise serializers.ValidationError('Fecha inválida, debe ser YYYY-MM-DD')          class DeceasedSerializer(serializers.ModelSerializer):     date_birth = DateOnlyField(required=False, allow_null=True)     date_death = DateOnlyField(required=False, allow_null=True)      class Meta:         model = Deceased         fields = [             'id_deceased', 'name', 'date_birth', 'date_death',             'description', 'burial_place', 'visualization_state',             'visualization_code'         ]      def get_date_birth(self, obj):         if obj.date_birth:             # Puede ser datetime o date, convertimos a date             return obj.date_birth.date() if hasattr(obj.date_birth, 'date') else obj.date_birth         return None      def get_date_death(self, obj):         if obj.date_death:             return obj.date_death.date() if hasattr(obj.date_death, 'date') else obj.date_death         return None      def to_internal_value(self, data):         # Para que la validación en POST/PUT acepte strings ISO y convierta a date correctamente         ret = super().to_internal_value(data)         return ret   class VideoSerializer(serializers.ModelSerializer):      class Meta:         model = Video         fields = '__all__'  class VideoMetadataSerializer(serializers.ModelSerializer):     class Meta:         model = VideoMetadata         fields = '__all__'  class DeceasedVideoSerializer(serializers.ModelSerializer):     class Meta:         model = DeceasedVideo         fields = '__all__'  class ImageSerializer(serializers.ModelSerializer):     class Meta:         model = Image         fields = '__all__'  class ImageMetadataSerializer(serializers.ModelSerializer):     class Meta:         model = ImageMetadata         fields = '__all__'  class DeceasedImageSerializer(serializers.ModelSerializer):     class Meta:         model = DeceasedImage         fields = '__all__'  class RelationshipTypeSerializer(serializers.ModelSerializer):     class Meta:         model = RelationshipType         fields = '__all__'  class RelationSerializer(serializers.ModelSerializer):     class Meta:         model = Relation         fields = '__all__'  class UserDeceasedSerializer(serializers.ModelSerializer):     class Meta:         model = UserDeceased         fields = '__all__'  class RequestSerializer(serializers.ModelSerializer):     class Meta:         model = Request         fields = '__all__'  class NotificationSerializer(serializers.ModelSerializer):     class Meta:         model = Notification         fields = '__all__'  class QRSerializer(serializers.ModelSerializer):     class Meta:         model = QR         fields = '__all__'   from django.test import TestCase  # Create your tests here.  from django.urls import path from . import views  # Importa las vistas de tu app                                                                            ||||                                                                                                                           ||||                                   ||||                                                                           |||| from .views import UserIdByQrCodeView, DeceasedByUserView, ImagesByDeceasedView, VideosByDeceasedView, RelationsByDeceasedView, DashboardView, AddFamilyMemberView, FamilyMemberListView, ShareFamilyMemberView, EditFamilyMemberView, DeleteFamilyMemberView, RequestAccessView, ApproveRequestView, NotificationsListView, MarkNotificationReadView, HandleNotificationActionView, OAuth2PasswordLoginView, DeceasedSearchView, UploadImageView, UploadVideoView, UserByEmailView   urlpatterns = [     # User     path('users/', views.UserListCreate.as_view()),     path('users/<int:pk>/', views.UserRetrieveUpdateDestroy.as_view()),     path('auth/login/', OAuth2PasswordLoginView.as_view(), name='oauth2_password_login'),          # Deceased     path('deceased/', views.DeceasedListCreate.as_view()),     path('deceased/<int:pk>/', views.DeceasedRetrieveUpdateDestroy.as_view()),          # Video     path('videos/', views.VideoListCreate.as_view()),     path('videos/<int:pk>/', views.VideoRetrieveUpdateDestroy.as_view()),          # Video Metadata     path('video-metadata/', views.VideoMetadataListCreate.as_view()),     path('video-metadata/<int:pk>/', views.VideoMetadataRetrieveUpdateDestroy.as_view()),          # Deceased-Video (Tabla puente) #Tiene problemas por ser pk compuesta (solo funciona el create)     path('deceased-videos/', views.DeceasedVideoListCreate.as_view()),     path('deceased-videos/<int:pk>/', views.DeceasedVideoRetrieveUpdateDestroy.as_view()),          # Image     path('images/', views.ImageListCreate.as_view()),     path('images/<int:pk>/', views.ImageRetrieveUpdateDestroy.as_view()),          # Image Metadata     path('image-metadata/', views.ImageMetadataListCreate.as_view()),     path('image-metadata/<int:pk>/', views.ImageMetadataRetrieveUpdateDestroy.as_view()),          # Deceased-Image (Tabla puente) #Tiene problemas por ser pk compuesta (solo funciona el create)      path('deceased-images/', views.DeceasedImageListCreate.as_view()),     path('deceased-images/<int:pk>/', views.DeceasedImageRetrieveUpdateDestroy.as_view()),          # Relationships # La pk es rara en esta tabla, la tiene en var y no en int, pero funciona bien     path('relationship-types/', views.RelationshipTypeListCreate.as_view()),     path('relationship-types/<str:pk>/', views.RelationshipTypeRetrieveUpdateDestroy.as_view()),     path('relations/', views.RelationListCreate.as_view()),     path('relations/<int:pk>/', views.RelationRetrieveUpdateDestroy.as_view()),          # User-Deceased #Tiene problemas por ser pk compuesta (solo funciona el create)      path('user-deceased/', views.UserDeceasedListCreate.as_view()),     path('user-deceased/<int:pk>/', views.UserDeceasedRetrieveUpdateDestroy.as_view()),          # Requests #Tiene problemas por ser pk compuesta (solo funciona el create)      path('requests/', views.RequestListCreate.as_view()),     path('requests/<int:pk>/', views.RequestRetrieveUpdateDestroy.as_view()),          # Notifications     path('notifications/', views.NotificationListCreate.as_view()),     path('notifications/<int:pk>/', views.NotificationRetrieveUpdateDestroy.as_view()),          # QR Codes     path('qr-codes/', views.QRListCreate.as_view()),     path('qr-codes/<int:pk>/', views.QRRetrieveUpdateDestroy.as_view()),      # Google AUTH     path('auth/google/', views.google_login, name='google_login'),      # APP VR     path('vr/user-id-by-qr/<int:qr_code>/', UserIdByQrCodeView.as_view(), name='user_id_by_qr'),     path('vr/deceased-by-user/<int:user_id>/', DeceasedByUserView.as_view(), name='deceased_by_user'),     path('vr/images-by-deceased/<int:deceased_id>/', ImagesByDeceasedView.as_view(), name='images_by_deceased'),     path('vr/videos-by-deceased/<int:deceased_id>/', VideosByDeceasedView.as_view(), name='videos_by_deceased'),     path('vr/relations-by-deceased/<int:deceased_id>/', RelationsByDeceasedView.as_view(), name='relations_by_deceased'),      # APP WEB     path('appweb/dashboard/', DashboardView.as_view(), name='appweb_dashboard'),     path('appweb/family-members/', FamilyMemberListView.as_view(), name='appweb_family_member_list'),     path('appweb/family-members/add/', AddFamilyMemberView.as_view(), name='appweb_add_family_member'),     path('appweb/family-members/<int:id>/share/', ShareFamilyMemberView.as_view(), name='appweb_share_family_member'),     path('appweb/family-members/<int:id>/edit/', EditFamilyMemberView.as_view(), name='appweb_edit_family_member'),     path('appweb/family-members/<int:id>/delete/', DeleteFamilyMemberView.as_view(), name='appweb_delete_family_member'),      path('appweb/request-access/<int:id_deceased>/', RequestAccessView.as_view(), name='appweb_request_access'),     path('appweb/approve-request/<int:request_id>/<str:action>/', ApproveRequestView.as_view(), name='appweb_approve_request'),      path('appweb/notifications/', NotificationsListView.as_view(), name='appweb_notifications'),     path('appweb/notifications/read/<int:notification_id>/', MarkNotificationReadView.as_view(), name='appweb_mark_notification_read'),     path('appweb/notification-action/<int:notification_id>/<str:action>/', HandleNotificationActionView.as_view(), name='appweb_handle_notification_action'),      # Búsqueda AJAX     path('deceased/search/', DeceasedSearchView.as_view(), name='deceased_search'),      # Upload Image & Video     path('upload/image/', UploadImageView.as_view(), name='upload_image'),     path('upload/video/', UploadVideoView.as_view(), name='upload_video'),      # Email Filter     path('users/by-email/', UserByEmailView.as_view(), name='user_by_email'), ]   from rest_framework import permissions from django.shortcuts import render from rest_framework import generics from .models import * from .serializers import * from rest_framework.parsers import MultiPartParser, FormParser  import json from django.http import JsonResponse from google.oauth2 import id_token from google.auth.transport import requests as google_requests from google.auth.transport import requests from django.contrib.auth import get_user_model from oauth2_provider.models import AccessToken, Application, RefreshToken from django.utils import timezone from datetime import timedelta from django.shortcuts import get_object_or_404   from django.views.decorators.csrf import csrf_exempt from django.utils.decorators import method_decorator from rest_framework.views import APIView from rest_framework.response import Response from rest_framework import status from django.db import connection, transaction from .serializers import DeceasedSerializer, RelationSerializer, UserDeceasedSerializer from .models import User, Deceased import re from django.contrib.auth import authenticate  from django.core.files.storage import FileSystemStorage import os from django.conf import settings   @method_decorator(csrf_exempt, name='dispatch')  # Para evitar problemas con CSRF en login class OAuth2PasswordLoginView(APIView):     permission_classes = []  # Sin restricciones para login      def post(self, request):         email = request.data.get('email')         password = request.data.get('password')          if not email or not password:             return Response({"error": "Email and password are required."}, status=status.HTTP_400_BAD_REQUEST)          user = authenticate(request, username=email, password=password)         if user is None:             return Response({"error": "Invalid credentials."}, status=status.HTTP_401_UNAUTHORIZED)          try:             app = Application.objects.get(name='Mausoleum API')         except Application.DoesNotExist:             return Response({'error': 'OAuth application not found'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)          expires = timezone.now() + timedelta(seconds=36000)         access_token_str = generate_token()         refresh_token_str = generate_token()          access_token = AccessToken.objects.create(             user=user,             application=app,             token=access_token_str,             expires=expires,             scope='read write'         )         refresh_token = RefreshToken.objects.create(             user=user,             token=refresh_token_str,             application=app,             access_token=access_token         )          return Response({             'access_token': access_token.token,             'expires_in': 36000,             'refresh_token': refresh_token.token,             'token_type': 'Bearer',             'scope': 'read write'         })  # User CRUD class UserListCreate(generics.ListCreateAPIView):     queryset = User.objects.all()     serializer_class = UserSerializer      def get_permissions(self):         if self.request.method == 'POST':             # Permitir crear sin autenticación             return [permissions.AllowAny()]         # Para otros métodos, requiere autenticación         return [permissions.IsAuthenticated()]  class UserRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = User.objects.all()     serializer_class = UserSerializer  # views.py (appServer)  # class UserByEmailView(APIView): #     permission_classes = []  # O protección según convenga  #     def get(self, request): #         email = request.GET.get('email') #         if not email: #             return Response({'error': 'Email parameter is required'}, status=status.HTTP_400_BAD_REQUEST)          #         User = get_user_model() #         try: #             user = User.objects.get(email=email) #             return Response({ #                 'id_user': user.id_user, #                 'name': user.name, #                 'email': user.email, #             }, status=status.HTTP_200_OK) #         except User.DoesNotExist: #             return Response({'error': 'User not found'}, status=status.HTTP_404_NOT_FOUND)  class UserByEmailView(APIView):     permission_classes = []  # Opcional protección      def get(self, request):         email = request.GET.get('email')         if not email:             return Response({'error': 'Email parameter is required'}, status=status.HTTP_400_BAD_REQUEST)                  User = get_user_model()         try:             user = User.objects.get(email=email)              # Obtener la aplicación OAuth             try:                 app = Application.objects.get(name='Mausoleum API')             except Application.DoesNotExist:                 return Response({'error': 'OAuth application not found'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)              # Eliminar tokens previos para evitar acumulación (opcional)             AccessToken.objects.filter(user=user, application=app).delete()             RefreshToken.objects.filter(user=user, application=app).delete()              expires = timezone.now() + timedelta(seconds=36000)             access_token_str = generate_token()             refresh_token_str = generate_token()              access_token = AccessToken.objects.create(                 user=user,                 application=app,                 token=access_token_str,                 expires=expires,                 scope='read write'             )             refresh_token = RefreshToken.objects.create(                 user=user,                 token=refresh_token_str,                 application=app,                 access_token=access_token             )              return Response({                 'id_user': user.id_user,                 'name': user.name,                 'email': user.email,                 'access_token': access_token.token,                 'expires_in': 36000,                 'refresh_token': refresh_token.token,                 'token_type': 'Bearer',                 'scope': 'read write',             }, status=status.HTTP_200_OK)                      except User.DoesNotExist:             return Response({'error': 'User not found'}, status=status.HTTP_404_NOT_FOUND)  # Deceased CRUD  class DeceasedListCreate(generics.ListCreateAPIView):     queryset = Deceased.objects.all()     serializer_class = DeceasedSerializer  class DeceasedRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = Deceased.objects.all()     serializer_class = DeceasedSerializer  # Video CRUD  class VideoListCreate(generics.ListCreateAPIView):     queryset = Video.objects.all()     serializer_class = VideoSerializer  class VideoRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = Video.objects.all()     serializer_class = VideoSerializer  class VideoMetadataListCreate(generics.ListCreateAPIView):     queryset = VideoMetadata.objects.all()     serializer_class = VideoMetadataSerializer  class VideoMetadataRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = VideoMetadata.objects.all()     serializer_class = VideoMetadataSerializer  # DeceasedVideo  class DeceasedVideoListCreate(generics.ListCreateAPIView):     queryset = DeceasedVideo.objects.all()     serializer_class = DeceasedVideoSerializer  class DeceasedVideoRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = DeceasedVideo.objects.all()     serializer_class = DeceasedVideoSerializer  # Image CRUD  class ImageListCreate(generics.ListCreateAPIView):     queryset = Image.objects.all()     serializer_class = ImageSerializer  class ImageRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = Image.objects.all()     serializer_class = ImageSerializer  class ImageMetadataListCreate(generics.ListCreateAPIView):     queryset = ImageMetadata.objects.all()     serializer_class = ImageMetadataSerializer  class ImageMetadataRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = ImageMetadata.objects.all()     serializer_class = ImageMetadataSerializer  # DecesedImage CRUD  class DeceasedImageListCreate(generics.ListCreateAPIView):     queryset = DeceasedImage.objects.all()     serializer_class = DeceasedImageSerializer  class DeceasedImageRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = DeceasedImage.objects.all()     serializer_class = DeceasedImageSerializer  # Relationship and Type CRUD  class RelationshipTypeListCreate(generics.ListCreateAPIView):     queryset = RelationshipType.objects.all()     serializer_class = RelationshipTypeSerializer  class RelationshipTypeRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = RelationshipType.objects.all()     serializer_class = RelationshipTypeSerializer  class RelationListCreate(generics.ListCreateAPIView):     queryset = Relation.objects.all()     serializer_class = RelationSerializer  class RelationRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = Relation.objects.all()     serializer_class = RelationSerializer  # UserDeceased CRUD  class UserDeceasedListCreate(generics.ListCreateAPIView):     queryset = UserDeceased.objects.all()     serializer_class = UserDeceasedSerializer  class UserDeceasedRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = UserDeceased.objects.all()     serializer_class = UserDeceasedSerializer  # Request CRUD  class RequestListCreate(generics.ListCreateAPIView):     queryset = Request.objects.all()     serializer_class = RequestSerializer  class RequestRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = Request.objects.all()     serializer_class = RequestSerializer  # Notify CRUD  class NotificationListCreate(generics.ListCreateAPIView):     queryset = Notification.objects.all()     serializer_class = NotificationSerializer  class NotificationRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = Notification.objects.all()     serializer_class = NotificationSerializer      # QR CRUD  class QRListCreate(generics.ListCreateAPIView):     queryset = QR.objects.all()     serializer_class = QRSerializer  class QRRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):     queryset = QR.objects.all()     serializer_class = QRSerializer  # APP VR  from rest_framework.views import APIView from rest_framework.response import Response from django.db import connection  # class UserIdByQrCodeView(APIView): #     def get(self, request, qr_code): #         with connection.cursor() as cursor: #             cursor.execute(""" #                 SELECT id_user, visualization_status #                 FROM TBL_QR #                 WHERE qr_code = %s #             """, [qr_code]) #             row = cursor.fetchone() #         if row: #             return Response({'id_user': row[0], 'visualization_status': row[1]}) #         elif row and row[1] == "private": # impedir la vizualización para el caso en que el codigo sea privado #             return Response({'detail': 'The visualization of this code is "PRIVATE"'}, status=404) #         return Response({'detail': 'QR code not found'}, status=404)  from oauthlib.common import generate_token from oauth2_provider.models import AccessToken, Application, RefreshToken from django.utils import timezone from datetime import timedelta  class UserIdByQrCodeView(APIView):     permission_classes = [permissions.AllowAny]       def get(self, request, qr_code):         with connection.cursor() as cursor:             cursor.execute("""                 SELECT id_user, visualization_status                 FROM TBL_QR                 WHERE qr_code = %s             """, [qr_code])             row = cursor.fetchone()                  if row:             id_user, visualization_status = row             if visualization_status == "private":                 return Response({'detail': 'The visualization of this code is "PRIVATE"'}, status=404)                          # Generar token OAuth para este usuario             try:                 app = Application.objects.get(name='Mausoleum API')             except Application.DoesNotExist:                 return Response({'error': 'OAuth application not found'}, status=500)                          user_model = get_user_model()             try:                 user = user_model.objects.get(pk=id_user)             except user_model.DoesNotExist:                 return Response({'error': 'User not found'}, status=404)                          expires = timezone.now() + timedelta(seconds=36000)             access_token_str = generate_token()             refresh_token_str = generate_token()              access_token = AccessToken.objects.create(                 user=user,                 application=app,                 token=access_token_str,                 expires=expires,                 scope='read write'             )             refresh_token = RefreshToken.objects.create(                 user=user,                 token=refresh_token_str,                 application=app,                 access_token=access_token             )              return Response({                 'id_user': id_user,                 'visualization_status': visualization_status,                 'access_token': access_token.token,                 'expires_in': 36000,                 'refresh_token': refresh_token.token,                 'token_type': 'Bearer',                 'scope': 'read write'             })         else:             return Response({'detail': 'QR code not found'}, status=404)   class DeceasedByUserView(APIView):     def get(self, request, user_id):         with connection.cursor() as cursor:             cursor.execute("""                 SELECT d.id_deceased, d.name, d.date_birth, d.date_death, d.description, d.burial_place, d.visualization_state, d.visualization_code                 FROM TBL_DECEASED d                 JOIN TBL_USER_DECEASED ud ON d.id_deceased = ud.id_deceased                 WHERE ud.id_user = %s             """, [user_id])             columns = [col[0] for col in cursor.description]             results = [dict(zip(columns, row)) for row in cursor.fetchall()]         return Response(results)  class ImagesByDeceasedView(APIView):     def get(self, request, deceased_id):         with connection.cursor() as cursor:             cursor.execute("""                 SELECT img.id_image, img.image_link, img.event_title, img.description, imd.date_created, imd.coordinates                 FROM TBL_DECEASED_IMAGE di                 JOIN TBL_IMAGE img ON di.id_image = img.id_image                 JOIN TBL_IMAGE_METADATA imd ON di.id_metadata = imd.id_metadata                 WHERE di.id_deceased = %s                 ORDER BY imd.date_created ASC             """, [deceased_id])             columns = [col[0] for col in cursor.description]             results = [dict(zip(columns, row)) for row in cursor.fetchall()]         return Response(results)  class VideosByDeceasedView(APIView):     def get(self, request, deceased_id):         with connection.cursor() as cursor:             cursor.execute("""                 SELECT vid.id_video, vid.video_link, vid.event_title, vid.description, vmd.date_created, vmd.coordinates                 FROM TBL_DECEASED_VIDEO dv                 JOIN TBL_VIDEO vid ON dv.id_video = vid.id_video                 JOIN TBL_VIDEO_METADATA vmd ON dv.id_metadata = vmd.id_metadata                 WHERE dv.id_deceased = %s                 ORDER BY vmd.date_created ASC             """, [deceased_id])             columns = [col[0] for col in cursor.description]             results = [dict(zip(columns, row)) for row in cursor.fetchall()]         return Response(results)  class RelationsByDeceasedView(APIView):     def get(self, request, deceased_id):         with connection.cursor() as cursor:             cursor.execute("""                 SELECT r.id_parent, d.name AS parent_name, rt.relationship                 FROM TBL_RELATION r                 JOIN TBL_RELATIONSHIP_TYPE rt ON r.relationship = rt.relationship                 JOIN TBL_DECEASED d ON r.id_parent = d.id_deceased                 WHERE r.id_deceased = %s             """, [deceased_id])             columns = [col[0] for col in cursor.description]             results = [dict(zip(columns, row)) for row in cursor.fetchall()]         return Response(results)   # Google AUTH  User = get_user_model()  def google_login(request):     if request.method != 'POST':         return JsonResponse({'error': 'POST method required'}, status=405)      try:         body = json.loads(request.body)     except json.JSONDecodeError:         return JsonResponse({'error': 'Invalid JSON'}, status=400)      token = body.get('id_token')     if not token:         return JsonResponse({'error': 'id_token missing'}, status=400)      try:         # Verificar token con Google         idinfo = id_token.verify_oauth2_token(token, google_requests.Request(), '776557165549-k3a59gfcinfnqfd67un5hufctjo4goht.apps.googleusercontent.com')         email = idinfo['email']     except ValueError:         return JsonResponse({'error': 'Invalid token'}, status=400)      user, created = User.objects.get_or_create(email=email)     if created:         user.set_unusable_password()         user.save()      try:         app = Application.objects.get(name='Mausoleum API')     except Application.DoesNotExist:         return JsonResponse({'error': 'OAuth application not found'}, status=500)      expires = timezone.now() + timedelta(seconds=36000)      # access_token = AccessToken.objects.create(     #     user=user,     #     application=app,     #     # token=AccessToken.generate_token(),     #     token=generate_token(),     #     expires=expires,     #     scope='read write'     # )     # refresh_token = RefreshToken.objects.create(     #     user=user,     #     # token=RefreshToken.generate_token(),     #     token=generate_token(),     #     application=app,     #     access_token=access_token     # )      from oauthlib.common import generate_token       access_token_str = generate_token()     refresh_token_str = generate_token()       access_token = AccessToken.objects.create(     user=user,     application=app,     token=access_token_str,     expires=expires,     scope='read write'     )     refresh_token = RefreshToken.objects.create(         user=user,         token=refresh_token_str,         application=app,         access_token=access_token     )        return JsonResponse({         'access_token': access_token.token,         'expires_in': 36000,         'refresh_token': refresh_token.token,         'token_type': 'Bearer',         'scope': 'read write'     })   # ----------------------- APP WEB  class DashboardView(APIView):     permission_classes = [permissions.IsAuthenticated]      def get(self, request):         user = request.user         notifications = []         unread_count = 0          with connection.cursor() as cursor:             cursor.execute("""                 SELECT * FROM TBL_NOTIFICATION WHERE id_receiver = %s ORDER BY creation_date DESC             """, [user.id_user])             columns = [col[0] for col in cursor.description]             for row in cursor.fetchall():                 notif = dict(zip(columns, row))                 match = re.search(r"Request #(\d+)", notif.get("message", ""))                 if match:                     notif["request_id"] = match.group(1)                 notifications.append(notif)              cursor.execute("""                 SELECT COUNT(*) FROM TBL_NOTIFICATION WHERE id_receiver = %s AND is_read = 0             """, [user.id_user])             unread_count = cursor.fetchone()[0]          user_data = {             "id_user": user.id_user,             "name": user.name,             "email": user.email,         }          return Response({             "user": user_data,             "notifications": notifications,             "unread_count": unread_count         })   from rest_framework.parsers import MultiPartParser, FormParser  class AddFamilyMemberView(APIView):     permission_classes = [permissions.IsAuthenticated]     parser_classes = [MultiPartParser, FormParser]  # para recibir multipart/form-data      @transaction.atomic     def post(self, request):         data = request.data  # llega como QueryDict          # 1) Crear el modelo Deceased, copiando la lógica de “form.save(commit=False) + descripción desde 'biography'”         deceased_data = {             'name': data.get('name'),             'date_birth': data.get('date_birth'),             'date_death': data.get('date_death'),             # En la versión monolítica hacías: new_deceased.description = request.POST.get('biography', '')             'description': data.get('biography', ''),          # <-- aquí usamos 'biography'             'burial_place': data.get('burial_place'),             'visualization_state': data.get('visualization_state', True),             'visualization_code': data.get('visualization_code'),         }          serializer = DeceasedSerializer(data=deceased_data)         if not serializer.is_valid():             return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)          new_deceased = serializer.save()         deceased_id = new_deceased.id_deceased          # 2) Insertar relaciones en TBL_RELATION (idéntico al monolito)         related_ids = data.getlist('related_deceased[]')         relationship_types = data.getlist('relationship_type[]')         if related_ids and relationship_types and len(related_ids) == len(relationship_types):             with connection.cursor() as cursor:                 for related_id, rel_type in zip(related_ids, relationship_types):                     if related_id and rel_type:                         cursor.execute("""                             INSERT INTO TBL_RELATION (id_deceased, id_parent, relationship)                             VALUES (%s, %s, %s)                         """, [deceased_id, int(related_id), rel_type])          # 3) Insertar vínculo en TBL_USER_DECEASED (usuario autenticado tiene permisos)         user = request.user         with connection.cursor() as cursor:             cursor.execute("""                 INSERT INTO TBL_USER_DECEASED (id_user, id_deceased, date_relation, has_permission)                 VALUES (%s, %s, %s, %s)             """, [user.id_user, deceased_id, timezone.now(), 1])          # 4) Procesar imágenes (idéntico al flujo del monolito, mismo orden de inserts)         fs_images = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'images'))         images = request.FILES.getlist('images')         for idx, image_file in enumerate(images):             filename = fs_images.save(image_file.name, image_file)             uploaded_file_url = fs_images.url(filename)             event_title = data.get(f'image_event_{idx}', '')             description = data.get(f'image_desc_{idx}', '')              with connection.cursor() as cursor:                 # 4.1) Insertar metadato en TBL_IMAGE_METADATA                 cursor.execute("""                     INSERT INTO TBL_IMAGE_METADATA (date_created, coordinates)                     VALUES (%s, %s)                 """, [timezone.now(), ""])                 metadata_id = cursor.lastrowid                  # 4.2) Insertar vínculo en la tabla puente TBL_DECEASED_IMAGE                 cursor.execute("""                     INSERT INTO TBL_DECEASED_IMAGE (id_deceased, id_metadata, image_link)                     VALUES (%s, %s, %s)                 """, [deceased_id, metadata_id, uploaded_file_url])                  # 4.3) Finalmente, insertar el registro en TBL_IMAGE                 cursor.execute("""                     INSERT INTO TBL_IMAGE (id_image, image_link, event_title, description)                     VALUES (%s, %s, %s, %s)                 """, [metadata_id, uploaded_file_url, event_title, description])          # 5) Procesar vídeos (idéntico al flujo del monolito, mismo orden de inserts)         fs_videos = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'videos'))         video_files = request.FILES.getlist('videos')         for idx, video_file in enumerate(video_files):             filename = fs_videos.save(video_file.name, video_file)             uploaded_file_url = fs_videos.url(filename)             event_title = data.get(f'video_event_{idx}', '')             description = data.get(f'video_desc_{idx}', '')              with connection.cursor() as cursor:                 # 5.1) Insertar metadato en TBL_VIDEO_METADATA                 cursor.execute("""                     INSERT INTO TBL_VIDEO_METADATA (date_created, coordinates)                     VALUES (%s, %s)                 """, [timezone.now(), ""])                 metadata_id = cursor.lastrowid                  # 5.2) Insertar vínculo en la tabla puente TBL_DECEASED_VIDEO                 cursor.execute("""                     INSERT INTO TBL_DECEASED_VIDEO (id_deceased, id_metadata, video_link)                     VALUES (%s, %s, %s)                 """, [deceased_id, metadata_id, uploaded_file_url])                  # 5.3) Finalmente, insertar el registro en TBL_VIDEO                 cursor.execute("""                     INSERT INTO TBL_VIDEO (id_video, video_link, event_title, description)                     VALUES (%s, %s, %s, %s)                 """, [metadata_id, uploaded_file_url, event_title, description])          # 6) Devolver el objeto creado (igual que en el monolito hacías redirect, aquí devolvemos JSON)         return Response(DeceasedSerializer(new_deceased).data, status=status.HTTP_201_CREATED)  class FamilyMemberListView(APIView):     permission_classes = [permissions.IsAuthenticated]      def get(self, request):         user = request.user         miembros = []         permisos = []         otros_deceased = []         notifications = []         unread_count = 0          with connection.cursor() as cursor:             # 1) Obtener fallecidos relacionados al usuario             cursor.execute("""                 SELECT d.id_deceased, d.name, d.date_birth, d.date_death, d.burial_place, ud.has_permission                  FROM TBL_DECEASED d                 INNER JOIN TBL_USER_DECEASED ud ON d.id_deceased = ud.id_deceased                 WHERE ud.id_user = %s             """, [user.id_user])              columns = [col[0] for col in cursor.description]             for row in cursor.fetchall():                 miembro = dict(zip(columns, row))                 permisos.append(miembro['has_permission'])                  deceased_id = miembro['id_deceased']                  # 1.a) Obtener imágenes de este fallecido                 cursor.execute("""                     SELECT im.id_metadata, i.image_link, i.event_title, i.description                     FROM TBL_DECEASED_IMAGE im                     JOIN TBL_IMAGE i ON im.id_metadata = i.id_image                     WHERE im.id_deceased = %s                     ORDER BY i.id_image ASC                 """, [deceased_id])                 image_columns = [col[0] for col in cursor.description]                 images = [dict(zip(image_columns, img_row)) for img_row in cursor.fetchall()]                  # 1.b) Obtener vídeos de este fallecido                 cursor.execute("""                     SELECT vm.id_metadata, v.video_link, v.event_title, v.description                     FROM TBL_DECEASED_VIDEO vm                     JOIN TBL_VIDEO v ON vm.id_metadata = v.id_video                     WHERE vm.id_deceased = %s                     ORDER BY v.id_video ASC                 """, [deceased_id])                 video_columns = [col[0] for col in cursor.description]                 videos = [dict(zip(video_columns, vid_row)) for vid_row in cursor.fetchall()]                  # 1.c) Agregar listas de imágenes y vídeos al miembro                 miembro['images'] = images                 miembro['videos'] = videos                  miembros.append(miembro)              # 2) Obtener otros fallecidos no relacionados al usuario             cursor.execute("""                 SELECT *                 FROM TBL_DECEASED                 WHERE id_deceased NOT IN (                     SELECT id_deceased FROM TBL_USER_DECEASED WHERE id_user = %s                 )             """, [user.id_user])              other_columns = [col[0] for col in cursor.description]             otros_deceased = [dict(zip(other_columns, row)) for row in cursor.fetchall()]              # 3) Obtener notificaciones del usuario             cursor.execute("""                 SELECT id_notification, id_sender, message, is_read, creation_date                 FROM TBL_NOTIFICATION                 WHERE id_receiver = %s                 ORDER BY creation_date DESC             """, [user.id_user])             notif_columns = [col[0] for col in cursor.description]             for row in cursor.fetchall():                 notif = dict(zip(notif_columns, row))                 # Extraer “Request #ID” si existe en el mensaje                 import re                 match = re.search(r"Request #(\d+)", notif.get("message", ""))                 if match:                     notif["request_id"] = match.group(1)                 notifications.append(notif)              # 4) Contar notificaciones sin leer             cursor.execute("""                 SELECT COUNT(*) FROM TBL_NOTIFICATION                 WHERE id_receiver = %s AND is_read = 0             """, [user.id_user])             unread_count = cursor.fetchone()[0]          return Response({             "miembros": miembros,             "permisos": permisos,             "otros_deceased": otros_deceased,             "notifications": notifications,             "unread_count": unread_count,         })  class ShareFamilyMemberView(APIView):     permission_classes = [permissions.IsAuthenticated]      def post(self, request, id):         email = request.data.get('email')         if not email:             return Response({"email": "This field is required."}, status=status.HTTP_400_BAD_REQUEST)          shared_user = User.objects.filter(email=email).first()         sender = request.user          if not shared_user:             return Response({"email": "User with this email does not exist."}, status=status.HTTP_400_BAD_REQUEST)          with connection.cursor() as cursor:             cursor.execute("""                 INSERT INTO TBL_NOTIFICATION (id_sender, id_receiver, message, is_read, creation_date)                 VALUES (%s, %s, %s, %s, %s)             """, [                 sender.id_user,                 shared_user.id_user,                 f"{sender.name} has shared memory ID {id} with you. Do you approve?",                 0,                 timezone.now()             ])          return Response({"detail": "Memory shared successfully."}, status=status.HTTP_200_OK)  # class EditFamilyMemberView(APIView): #     permission_classes = [permissions.IsAuthenticated] #     parser_classes = [MultiPartParser, FormParser]   # <— importante para recibir archivos y form-data  #     @transaction.atomic #     def put(self, request, id): #         # 1) Obtener objeto Deceased o 404 #         miembro = get_object_or_404(Deceased, id_deceased=id) #         user = request.user  #         # 2) Verificar que el usuario tenga permiso en TBL_USER_DECEASED #         with connection.cursor() as cursor: #             cursor.execute(""" #                 SELECT has_permission FROM TBL_USER_DECEASED #                 WHERE id_user = %s AND id_deceased = %s #             """, [user.id_user, id]) #             perm = cursor.fetchone() #             if not perm: #                 return Response({"detail": "No permission to edit this deceased."}, #                                 status=status.HTTP_403_FORBIDDEN)  #         # 3) Usar DeceasedSerializer para actualizar los campos principales #         #    (name, date_birth, date_death, description, burial_place, visualization_state, visualization_code) #         serializer = DeceasedSerializer(miembro, data=request.data, partial=True) #         if not serializer.is_valid(): #             return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) #         serializer.save()  #         # 4) Manejo de relaciones en TBL_RELATION #         related_ids = request.data.getlist('related_deceased[]') #         relationship_types = request.data.getlist('relationship_type[]') #         deleted_relation_ids = request.data.getlist('deleted_relation_ids[]')  #         with connection.cursor() as cursor: #             # - Eliminar relaciones marcadas para borrar #             for del_id in deleted_relation_ids: #                 cursor.execute(""" #                     DELETE FROM TBL_RELATION #                     WHERE id_deceased = %s AND id_parent = %s #                 """, [id, del_id])  #             # - Obtener relaciones existentes #             cursor.execute("SELECT id_parent FROM TBL_RELATION WHERE id_deceased = %s", [id]) #             existing_ids = set(row[0] for row in cursor.fetchall())  #             # - Insertar relaciones nuevas si no existen #             for related_id, rel_type in zip(related_ids, relationship_types): #                 if related_id and rel_type and int(related_id) not in existing_ids: #                     cursor.execute(""" #                         INSERT INTO TBL_RELATION (id_deceased, id_parent, relationship) #                         VALUES (%s, %s, %s) #                     """, [id, int(related_id), rel_type])  #         # 5) Manejo de imágenes #         #    5.1) Borrar las que vienen en delete_image_ids[] #         #    5.2) Actualizar event_title/description de existing_image_id[] #         #    5.3) Guardar nuevas imágenes de request.FILES.getlist('images') #         with connection.cursor() as cursor: #             # 5.1) Eliminar imágenes marcadas #             delete_image_ids = request.data.getlist('delete_image_ids[]') #             for del_id in delete_image_ids: #                 # quitar vínculo en la tabla puente y eliminar registros de imagen #                 cursor.execute("DELETE FROM TBL_DECEASED_IMAGE WHERE id_metadata = %s", [del_id]) #                 cursor.execute("DELETE FROM TBL_IMAGE WHERE id_image = %s", [del_id])  #             # 5.2) Actualizar las etiquetas de las imágenes existentes #             existing_image_ids = request.data.getlist('existing_image_id[]') #             for idx, img_id in enumerate(existing_image_ids): #                 event = request.data.get(f'existing_image_event_{idx}', '')   # nombre del campo en el form #                 desc = request.data.get(f'existing_image_desc_{idx}', '') #                 cursor.execute(""" #                     UPDATE TBL_IMAGE #                     SET event_title = %s, #                         description = %s #                     WHERE id_image = %s #                 """, [event, desc, img_id])  #             # 5.3) Guardar nuevas imágenes #             fs_imagenes = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'images')) #             for idx, image_file in enumerate(request.FILES.getlist('images')): #                 filename = fs_imagenes.save(image_file.name, image_file) #                 uploaded_file_url = fs_imagenes.url(filename) #                 event = request.data.get(f'image_event_{idx}', '') #                 desc = request.data.get(f'image_desc_{idx}', '')  #                 # - Creamos un registro en TBL_IMAGE_METADATA #                 cursor.execute(""" #                     INSERT INTO TBL_IMAGE_METADATA (date_created, coordinates) #                     VALUES (%s, %s) #                 """, [timezone.now(), ""]) #                 metadata_id = cursor.lastrowid  #                 # - Insertar vínculo en la tabla puente #                 cursor.execute(""" #                     INSERT INTO TBL_DECEASED_IMAGE (id_deceased, id_metadata, image_link) #                     VALUES (%s, %s, %s) #                 """, [id, metadata_id, uploaded_file_url])  #                 # - Insertar el registro en TBL_IMAGE #                 cursor.execute(""" #                     INSERT INTO TBL_IMAGE (id_image, image_link, event_title, description) #                     VALUES (%s, %s, %s, %s) #                 """, [metadata_id, uploaded_file_url, event, desc])  #         # 6) Manejo de vídeos (igual que imágenes) #         with connection.cursor() as cursor: #             # 6.1) Eliminar vídeos marcados #             delete_video_ids = request.data.getlist('delete_video_ids[]') #             for del_id in delete_video_ids: #                 cursor.execute("DELETE FROM TBL_DECEASED_VIDEO WHERE id_metadata = %s", [del_id]) #                 cursor.execute("DELETE FROM TBL_VIDEO WHERE id_video = %s", [del_id])  #             # 6.2) Actualizar metadata de vídeos existentes #             existing_video_ids = request.data.getlist('existing_video_id[]') #             for idx, vid_id in enumerate(existing_video_ids): #                 event = request.data.get(f'existing_video_event_{idx}', '') #                 desc = request.data.get(f'existing_video_desc_{idx}', '') #                 cursor.execute(""" #                     UPDATE TBL_VIDEO #                     SET event_title = %s, #                         description = %s #                     WHERE id_video = %s #                 """, [event, desc, vid_id])  #             # 6.3) Guardar nuevos vídeos #             fs_videos = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'videos')) #             for idx, video_file in enumerate(request.FILES.getlist('videos')): #                 filename = fs_videos.save(video_file.name, video_file) #                 uploaded_video_url = fs_videos.url(filename) #                 event = request.data.get(f'video_event_{idx}', '') #                 desc = request.data.get(f'video_desc_{idx}', '')  #                 # - Insertar metadato en TBL_VIDEO_METADATA #                 cursor.execute(""" #                     INSERT INTO TBL_VIDEO_METADATA (date_created, coordinates) #                     VALUES (%s, %s) #                 """, [timezone.now(), ""]) #                 metadata_id = cursor.lastrowid  #                 # - Insertar vínculo en la tabla puente #                 cursor.execute(""" #                     INSERT INTO TBL_DECEASED_VIDEO (id_deceased, id_metadata, video_link) #                     VALUES (%s, %s, %s) #                 """, [id, metadata_id, uploaded_video_url])  #                 # - Insertar en TBL_VIDEO #                 cursor.execute(""" #                     INSERT INTO TBL_VIDEO (id_video, video_link, event_title, description) #                     VALUES (%s, %s, %s, %s) #                 """, [metadata_id, uploaded_video_url, event, desc])  #         # 7) Todo OK, devolvemos la entidad actualizada (puedes devolver el serializer o simplemente status 200) #         return Response(serializer.data, status=status.HTTP_200_OK)  # api/views.py  (AppServer)  from datetime import datetime import os from django.shortcuts import get_object_or_404 from django.db import connection, transaction from django.core.files.storage import FileSystemStorage  from rest_framework.views import APIView from rest_framework import permissions, status from rest_framework.parsers import MultiPartParser, FormParser, JSONParser from rest_framework.response import Response  from .models import Deceased from .serializers import DeceasedSerializer  # api/views.py  (AppServer)  from datetime import datetime import os  from django.shortcuts import get_object_or_404 from django.db import connection, transaction from django.core.files.storage import FileSystemStorage  from rest_framework.views import APIView from rest_framework import permissions, status from rest_framework.parsers import MultiPartParser, FormParser, JSONParser from rest_framework.response import Response  from .models import Deceased  # Asegúrate de que aquí esté correctamente importado from .serializers import DeceasedSerializer  # Lo seguiremos usando solo para validación  ### EditFamilyMemberView (AppServer) con UPDATE manual  # api/views.py  (AppServer)  from datetime import datetime import os  from django.shortcuts import get_object_or_404 from django.db import connection, transaction from django.core.files.storage import FileSystemStorage  from rest_framework.views import APIView from rest_framework import permissions, status from rest_framework.parsers import MultiPartParser, FormParser, JSONParser from rest_framework.response import Response  from .models import Deceased from .serializers import DeceasedSerializer  # Solo para validación si se necesita   class EditFamilyMemberView(APIView):     permission_classes = [permissions.IsAuthenticated]     parser_classes = [MultiPartParser, FormParser, JSONParser]      @transaction.atomic     def put(self, request, id):         # 1) Obtener el objeto o 404         miembro = get_object_or_404(Deceased, id_deceased=id)         user = request.user          # 2) Verificar permiso en TBL_USER_DECEASED         with connection.cursor() as cursor:             cursor.execute("""                 SELECT has_permission                    FROM TBL_USER_DECEASED                  WHERE id_user = %s AND id_deceased = %s             """, [user.id_user, id])             if not cursor.fetchone():                 return Response({"detail": "No permission to edit this deceased."},                                 status=status.HTTP_403_FORBIDDEN)          # 3) Extraer y validar manualmente los campos principales         data = request.data  # JSON enviado por AppWeb          name_str         = data.get('name', None)         date_birth_str   = data.get('date_birth', None)         date_death_str   = data.get('date_death', None)         description_str  = data.get('description', None)         burial_place_str = data.get('burial_place', None)          # Validaciones básicas         if name_str is not None and len(name_str) > 100:             return Response({"name": "Máximo 100 caracteres."}, status=status.HTTP_400_BAD_REQUEST)         if description_str is not None and len(description_str) > 100:             return Response({"description": "Máximo 100 caracteres."}, status=status.HTTP_400_BAD_REQUEST)          # Parsear fechas YYYY-MM-DD         date_birth_val = None         if date_birth_str:             try:                 date_birth_val = datetime.strptime(date_birth_str, '%Y-%m-%d')             except ValueError:                 return Response({"date_birth": "Formato inválido, debe ser 'YYYY-MM-DD'"},                                 status=status.HTTP_400_BAD_REQUEST)          date_death_val = None         if date_death_str:             try:                 date_death_val = datetime.strptime(date_death_str, '%Y-%m-%d')             except ValueError:                 return Response({"date_death": "Formato inválido, debe ser 'YYYY-MM-DD'"},                                 status=status.HTTP_400_BAD_REQUEST)          # 4) Construir dinámicamente el UPDATE SQL para no sobrescribir con NULL         campos = []         valores = []          if name_str is not None:             campos.append("name = %s")             valores.append(name_str)         if date_birth_val is not None:             campos.append("date_birth = %s")             valores.append(date_birth_val)         if date_death_val is not None:             campos.append("date_death = %s")             valores.append(date_death_val)         if description_str is not None:             campos.append("description = %s")             valores.append(description_str)         if burial_place_str is not None:             campos.append("burial_place = %s")             valores.append(burial_place_str)          if campos:             set_clause = ", ".join(campos)             valores.append(id)             sql = f"UPDATE TBL_DECEASED SET {set_clause} WHERE id_deceased = %s"             with connection.cursor() as cursor:                 cursor.execute(sql, valores)          # Verificar en consola         miembro.refresh_from_db()         print("DEBUG — AppServer: tras UPDATE, miembro.name        =", miembro.name)         print("DEBUG — AppServer: tras UPDATE, miembro.date_birth  =", miembro.date_birth)         print("DEBUG — AppServer: tras UPDATE, miembro.date_death  =", miembro.date_death)         print("DEBUG — AppServer: tras UPDATE, miembro.description =", miembro.description)         print("DEBUG — AppServer: tras UPDATE, miembro.burial_place=", miembro.burial_place)          # 5) Manejo de relaciones         if hasattr(data, 'getlist'):             related_ids = data.getlist('related_deceased[]')             relationship_types = data.getlist('relationship_type[]')             deleted_relation_ids = data.getlist('deleted_relation_ids[]')         else:             related_ids = data.get('related_deceased', [])             relationship_types = data.get('relationship_type', [])             deleted_relation_ids = data.get('deleted_relation_ids', [])          with connection.cursor() as cursor:             for del_id in deleted_relation_ids:                 cursor.execute("""                     DELETE FROM TBL_RELATION                      WHERE id_deceased = %s AND id_parent = %s                 """, [id, del_id])             cursor.execute("SELECT id_parent FROM TBL_RELATION WHERE id_deceased = %s", [id])             existing_ids = set(row[0] for row in cursor.fetchall())             for rid, rtype in zip(related_ids, relationship_types):                 if rid and rtype and int(rid) not in existing_ids:                     cursor.execute("""                         INSERT INTO TBL_RELATION (id_deceased, id_parent, relationship)                         VALUES (%s, %s, %s)                     """, [id, int(rid), rtype])          # 6) Manejo de imágenes         if hasattr(data, 'getlist'):             delete_image_ids   = data.getlist('delete_image_ids[]')             existing_image_ids = data.getlist('existing_image_id[]')         else:             delete_image_ids   = data.get('delete_image_ids', [])             existing_image_ids = data.get('existing_image_id', [])          with connection.cursor() as cursor:             for del_id in delete_image_ids:                 cursor.execute("DELETE FROM TBL_DECEASED_IMAGE WHERE id_metadata = %s", [del_id])                 cursor.execute("DELETE FROM TBL_IMAGE WHERE id_image = %s", [del_id])             for idx, img_id in enumerate(existing_image_ids):                 event = data.get(f'existing_image_event_{idx}', '')                 desc  = data.get(f'existing_image_desc_{idx}', '')                 cursor.execute("""                     UPDATE TBL_IMAGE                        SET event_title = %s, description = %s                      WHERE id_image = %s                 """, [event, desc, img_id])             fs_imagenes = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'images'))             for idx, image_file in enumerate(request.FILES.getlist('images')):                 filename = fs_imagenes.save(image_file.name, image_file)                 url = fs_imagenes.url(filename)                 event = data.get(f'image_event_{idx}', '')                 desc  = data.get(f'image_desc_{idx}', '')                 cursor.execute("INSERT INTO TBL_IMAGE_METADATA (date_created, coordinates) VALUES (%s, %s)", [datetime.now(), ""])                 metadata_id = cursor.lastrowid                 cursor.execute("INSERT INTO TBL_DECEASED_IMAGE (id_deceased, id_metadata, image_link) VALUES (%s, %s, %s)", [id, metadata_id, url])                 cursor.execute("INSERT INTO TBL_IMAGE (id_image, image_link, event_title, description) VALUES (%s, %s, %s, %s)", [metadata_id, url, event, desc])          # 7) Manejo de vídeos (análogo)         if hasattr(data, 'getlist'):             delete_video_ids   = data.getlist('delete_video_ids[]')             existing_video_ids = data.getlist('existing_video_id[]')         else:             delete_video_ids   = data.get('delete_video_ids', [])             existing_video_ids = data.get('existing_video_id', [])          with connection.cursor() as cursor:             for del_id in delete_video_ids:                 cursor.execute("DELETE FROM TBL_DECEASED_VIDEO WHERE id_metadata = %s", [del_id])                 cursor.execute("DELETE FROM TBL_VIDEO WHERE id_video = %s", [del_id])             for idx, vid_id in enumerate(existing_video_ids):                 event = data.get(f'existing_video_event_{idx}', '')                 desc  = data.get(f'existing_video_desc_{idx}', '')                 cursor.execute("""                     UPDATE TBL_VIDEO                        SET event_title = %s, description = %s                      WHERE id_video = %s                 """, [event, desc, vid_id])             fs_videos = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'videos'))             for idx, video_file in enumerate(request.FILES.getlist('videos')):                 filename = fs_videos.save(video_file.name, video_file)                 url = fs_videos.url(filename)                 event = data.get(f'video_event_{idx}', '')                 desc  = data.get(f'video_desc_{idx}', '')                 cursor.execute("INSERT INTO TBL_VIDEO_METADATA (date_created, coordinates) VALUES (%s, %s)", [datetime.now(), ""])                 metadata_id = cursor.lastrowid                 cursor.execute("INSERT INTO TBL_DECEASED_VIDEO (id_deceased, id_metadata, video_link) VALUES (%s, %s, %s)", [id, metadata_id, url])                 cursor.execute("INSERT INTO TBL_VIDEO (id_video, video_link, event_title, description) VALUES (%s, %s, %s, %s)", [metadata_id, url, event, desc])          # 8) Devolver JSON con datos actualizados         return Response({             "id_deceased": miembro.id_deceased,             "name": miembro.name,             "date_birth": miembro.date_birth.isoformat() if miembro.date_birth else None,             "date_death": miembro.date_death.isoformat() if miembro.date_death else None,             "description": miembro.description,             "burial_place": miembro.burial_place,             "visualization_state": miembro.visualization_state,             "visualization_code": miembro.visualization_code,         }, status=status.HTTP_200_OK)    class DeleteFamilyMemberView(APIView):     permission_classes = [permissions.IsAuthenticated]      @transaction.atomic     def delete(self, request, id):         try:             miembro = Deceased.objects.get(id_deceased=id)         except Deceased.DoesNotExist:             return Response({"detail": "Deceased not found."}, status=status.HTTP_404_NOT_FOUND)          with connection.cursor() as cursor:             cursor.execute("DELETE FROM TBL_RELATION WHERE id_deceased = %s OR id_parent = %s", [id, id])              cursor.execute("SELECT id_metadata FROM TBL_DECEASED_VIDEO WHERE id_deceased = %s", [id])             video_metadata_ids = [row[0] for row in cursor.fetchall()]             cursor.execute("DELETE FROM TBL_DECEASED_VIDEO WHERE id_deceased = %s", [id])             for meta_id in video_metadata_ids:                 cursor.execute("DELETE FROM TBL_VIDEO WHERE id_video = %s", [meta_id])                 cursor.execute("DELETE FROM TBL_VIDEO_METADATA WHERE id_metadata = %s", [meta_id])              cursor.execute("SELECT id_metadata FROM TBL_DECEASED_IMAGE WHERE id_deceased = %s", [id])             image_metadata_ids = [row[0] for row in cursor.fetchall()]             cursor.execute("DELETE FROM TBL_DECEASED_IMAGE WHERE id_deceased = %s", [id])             for meta_id in image_metadata_ids:                 cursor.execute("DELETE FROM TBL_IMAGE WHERE id_image = %s", [meta_id])                 cursor.execute("DELETE FROM TBL_IMAGE_METADATA WHERE id_metadata = %s", [meta_id])              cursor.execute("DELETE FROM TBL_USER_DECEASED WHERE id_deceased = %s", [id])             cursor.execute("DELETE FROM TBL_REQUEST WHERE id_deceased = %s", [id])             cursor.execute("DELETE FROM TBL_DECEASED WHERE id_deceased = %s", [id])          return Response({"detail": "Deceased deleted successfully."}, status=status.HTTP_204_NO_CONTENT)   # Puedes crear más vistas para request_access, approve_request, notifications, etc. siguiendo el mismo patrón de APIView con JSON y serializers.  class RequestAccessView(APIView):     permission_classes = [permissions.IsAuthenticated]      @transaction.atomic     def post(self, request, id_deceased):         user = request.user          with connection.cursor() as cursor:             # Verificar si ya hay solicitud pendiente del mismo usuario y fallecido             cursor.execute("""                 SELECT COUNT(*) FROM TBL_REQUEST                 WHERE id_issuer = %s AND id_deceased = %s AND request_status = 'pending'             """, [user.id_user, id_deceased])             if cursor.fetchone()[0] > 0:                 return Response({"detail": "You already have a pending request for this deceased."},                                 status=status.HTTP_400_BAD_REQUEST)              # Obtener creador (usuario con permiso) del fallecido             cursor.execute("""                 SELECT id_user FROM TBL_USER_DECEASED                 WHERE id_deceased = %s AND has_permission = 1 LIMIT 1             """, [id_deceased])             creator = cursor.fetchone()             if not creator:                 return Response({"detail": "No creator with permission found for this deceased."},                                 status=status.HTTP_404_NOT_FOUND)             creator_id = creator[0]              # Insertar solicitud             cursor.execute("""                 INSERT INTO TBL_REQUEST (id_issuer, id_receiver, id_deceased, creation_date, request_type, request_status)                 VALUES (%s, %s, %s, %s, %s, %s)             """, [user.id_user, creator_id, id_deceased, timezone.now(), 'view', 'pending'])             request_id = cursor.lastrowid              # Insertar notificación al creador             cursor.execute("""                 INSERT INTO TBL_NOTIFICATION (id_sender, id_receiver, message, creation_date, is_read)                 VALUES (%s, %s, %s, %s, %s)             """, [user.id_user, creator_id, f"{user.name} has requested access. Request #{request_id}", timezone.now(), False])          return Response({"detail": "Access request created successfully."}, status=status.HTTP_201_CREATED)   class ApproveRequestView(APIView):     permission_classes = [permissions.IsAuthenticated]      @transaction.atomic     def post(self, request, request_id, action):         if action not in ['approved', 'rejected']:             return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)          approver = request.user          with connection.cursor() as cursor:             cursor.execute("""                 SELECT id_issuer, id_deceased FROM TBL_REQUEST WHERE id_request = %s             """, [request_id])             row = cursor.fetchone()             if not row:                 return Response({"detail": "Request not found."}, status=status.HTTP_404_NOT_FOUND)              requester_id, deceased_id = row              cursor.execute("""                 UPDATE TBL_REQUEST SET request_status = %s WHERE id_request = %s             """, [action, request_id])              if action == 'approved':                 cursor.execute("""                     DELETE FROM TBL_USER_DECEASED WHERE id_user = %s AND id_deceased = %s                 """, [requester_id, deceased_id])                  cursor.execute("""                     INSERT INTO TBL_USER_DECEASED (id_user, id_deceased, date_relation, has_permission)                     VALUES (%s, %s, %s, %s)                 """, [requester_id, deceased_id, timezone.now(), False])                  message = f"✅ Your request to access memory ID {deceased_id} was approved."             else:                 message = f"❌ Your request to access memory ID {deceased_id} was rejected."              cursor.execute("""                 INSERT INTO TBL_NOTIFICATION (id_sender, id_receiver, message, creation_date, is_read)                 VALUES (%s, %s, %s, %s, %s)             """, [approver.id_user, requester_id, message, timezone.now(), False])              # MARCAR LA NOTIFICACIÓN ORIGINAL COMO LEÍDA             cursor.execute("""                 UPDATE TBL_NOTIFICATION SET is_read = 1                 WHERE id_receiver = %s AND message LIKE %s             """, [approver.id_user, f"%Request #{request_id}%"])          return Response({"detail": f"Request {action} successfully."}, status=status.HTTP_200_OK)    class NotificationsListView(APIView):     permission_classes = [permissions.IsAuthenticated]      def get(self, request):         user = request.user         notifications = []         with connection.cursor() as cursor:             cursor.execute("""                 SELECT id_notification, id_sender, message, is_read, creation_date                 FROM TBL_NOTIFICATION                 WHERE id_receiver = %s                 ORDER BY creation_date DESC             """, [user.id_user])              columns = [col[0] for col in cursor.description]             for row in cursor.fetchall():                 notifications.append(dict(zip(columns, row)))          return Response(notifications)    class MarkNotificationReadView(APIView):     permission_classes = [permissions.IsAuthenticated]      def post(self, request, notification_id):         user = request.user         with connection.cursor() as cursor:             cursor.execute("""                 UPDATE TBL_NOTIFICATION SET is_read = 1                 WHERE id_notification = %s AND id_receiver = %s             """, [notification_id, user.id_user])             if cursor.rowcount == 0:                 return Response({"detail": "Notification not found or no permission."}, status=status.HTTP_404_NOT_FOUND)         return Response({"detail": "Notification marked as read."}, status=status.HTTP_200_OK)   class HandleNotificationActionView(APIView):     permission_classes = [permissions.IsAuthenticated]      @transaction.atomic     def post(self, request, notification_id, action):         user = request.user          if action not in ['accept', 'decline', 'read']:             return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)          with connection.cursor() as cursor:             cursor.execute("""                 SELECT id_sender, message FROM TBL_NOTIFICATION                 WHERE id_notification = %s AND id_receiver = %s             """, [notification_id, user.id_user])             notif = cursor.fetchone()              if not notif:                 return Response({"detail": "Notification not found or no permission."}, status=status.HTTP_404_NOT_FOUND)              sender_id, message = notif              # Caso: solicitud de acceso con ID de request             match_request = re.search(r"Request #(\d+)", message)             if match_request:                 request_id = int(match_request.group(1))                  cursor.execute("SELECT id_deceased FROM TBL_REQUEST WHERE id_request = %s", [request_id])                 row = cursor.fetchone()                 if not row:                     return Response({"detail": "Request data not found."}, status=status.HTTP_404_NOT_FOUND)                 id_deceased = row[0]                  if action == 'accept':                     cursor.execute("""                         INSERT IGNORE INTO TBL_USER_DECEASED (id_user, id_deceased, date_relation, has_permission)                         VALUES (%s, %s, %s, %s)                     """, [user.id_user, id_deceased, timezone.now(), False])              # 🔥 Nuevo caso: notificación de memoria compartida             match_shared = re.search(r"shared memory ID (\d+)", message)             if match_shared:                 id_deceased = int(match_shared.group(1))                  if action == 'accept':                     cursor.execute("""                         INSERT IGNORE INTO TBL_USER_DECEASED (id_user, id_deceased, date_relation, has_permission)                         VALUES (%s, %s, %s, %s)                     """, [user.id_user, id_deceased, timezone.now(), False])              # Marcar la notificación como leída siempre             cursor.execute("""                 UPDATE TBL_NOTIFICATION SET is_read = 1 WHERE id_notification = %s             """, [notification_id])          return Response({"detail": f"Notification action '{action}' handled."}, status=status.HTTP_200_OK)   class DeceasedSearchView(APIView):     def get(self, request):         query = request.GET.get('q', '').strip()         results = []         if query:             with connection.cursor() as cursor:                 cursor.execute("""                     SELECT id_deceased, name FROM TBL_DECEASED                     WHERE LOWER(name) LIKE %s                     LIMIT 10                 """, [f"%{query.lower()}%"])                 rows = cursor.fetchall()                 for row in rows:                     results.append({'id': row[0], 'name': row[1]})         return Response({'results': results})   class UploadImageView(APIView):     permission_classes = [permissions.IsAuthenticated]      def post(self, request):         image_file = request.FILES.get('image_file')         event_title = request.data.get('event_title', '')         description = request.data.get('description', '')         id_deceased = request.data.get('id_deceased')          if not image_file or not id_deceased:             return Response({'error': 'Missing image file or deceased ID'}, status=status.HTTP_400_BAD_REQUEST)          fs = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'images'))         filename = fs.save(image_file.name, image_file)         uploaded_file_url = fs.url(filename)          with connection.cursor() as cursor:             cursor.execute("""                 INSERT INTO TBL_IMAGE_METADATA (date_created, coordinates)                 VALUES (%s, %s)             """, [timezone.now(), ''])             metadata_id = cursor.lastrowid              cursor.execute("""                 INSERT INTO TBL_DECEASED_IMAGE (id_deceased, id_metadata, image_link)                 VALUES (%s, %s, %s)             """, [id_deceased, metadata_id, uploaded_file_url])              cursor.execute("""                 INSERT INTO TBL_IMAGE (id_image, image_link, event_title, description)                 VALUES (%s, %s, %s, %s)             """, [metadata_id, uploaded_file_url, event_title, description])          return Response({             'message': 'Image uploaded successfully',             'image_link': uploaded_file_url,             'id_metadata': metadata_id,         }, status=status.HTTP_201_CREATED)  class UploadVideoView(APIView):     permission_classes = [permissions.IsAuthenticated]      def post(self, request):         video_file = request.FILES.get('video_file')         event_title = request.data.get('event_title', '')         description = request.data.get('description', '')         id_deceased = request.data.get('id_deceased')          if not video_file or not id_deceased:             return Response({'error': 'Missing video file or deceased ID'}, status=status.HTTP_400_BAD_REQUEST)          fs = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads', 'videos'))         filename = fs.save(video_file.name, video_file)         uploaded_file_url = fs.url(filename)          with connection.cursor() as cursor:             cursor.execute("""                 INSERT INTO TBL_VIDEO_METADATA (date_created, coordinates)                 VALUES (%s, %s)             """, [timezone.now(), ''])             metadata_id = cursor.lastrowid              cursor.execute("""                 INSERT INTO TBL_DECEASED_VIDEO (id_deceased, id_metadata, video_link)                 VALUES (%s, %s, %s)             """, [id_deceased, metadata_id, uploaded_file_url])              cursor.execute("""                 INSERT INTO TBL_VIDEO (id_video, video_link, event_title, description)                 VALUES (%s, %s, %s, %s)             """, [metadata_id, uploaded_file_url, event_title, description])          return Response({             'message': 'Video uploaded successfully',             'video_link': uploaded_file_url,             'id_metadata': metadata_id,         }, status=status.HTTP_201_CREATED)    

Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\code\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\mausoleum_server\output.txt
""" ASGI config for mausoleum_server project.  It exposes the ASGI callable as a module-level variable named ``application``.  For more information on this file, see https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/ """  import os  from django.core.asgi import get_asgi_application  os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mausoleum_server.settings')  application = get_asgi_application()  """ Django settings for mausoleum_server project.  Generated by 'django-admin startproject' using Django 5.2.1.  For more information on this file, see https://docs.djangoproject.com/en/5.2/topics/settings/  For the full list of settings and their values, see https://docs.djangoproject.com/en/5.2/ref/settings/ """  from pathlib import Path  # Build paths inside the project like this: BASE_DIR / 'subdir'. BASE_DIR = Path(__file__).resolve().parent.parent   # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/  # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = 'django-insecure-jfiusc2r@@)z7u+x#=%x5dh*xb7=y)+vx^huuffwbk81p^i_7+'  # SECURITY WARNING: don't run with debug turned on in production! DEBUG = True  ALLOWED_HOSTS = []  AUTHENTICATION_BACKENDS = (     'social_core.backends.google.GoogleOAuth2',     'django.contrib.auth.backends.ModelBackend',  # tu backend por defecto )  SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = '776557165549-k3a59gfcinfnqfd67un5hufctjo4goht.apps.googleusercontent.com' SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = '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'  # URLS de login y redirección  LOGIN_URL = 'login' LOGIN_REDIRECT_URL = '/api/users/'  # o donde quieras que vaya tras login LOGOUT_REDIRECT_URL = '/'   # Callback de redirección SOCIAL_AUTH_GOOGLE_OAUTH2_REDIRECT_URI = 'http://localhost:8000/auth/complete/google-oauth2/'   # Application definition  INSTALLED_APPS = [     'django.contrib.admin',     'django.contrib.auth',     'django.contrib.contenttypes',     'django.contrib.sessions',     'django.contrib.messages',     'django.contrib.staticfiles',     'oauth2_provider',     'rest_framework',     'social_django',     'api', ]  MIDDLEWARE = [     'api.middleware.TokenValidationMiddleware',     'django.middleware.security.SecurityMiddleware',     'django.contrib.sessions.middleware.SessionMiddleware',     'django.middleware.common.CommonMiddleware',     'django.middleware.csrf.CsrfViewMiddleware',     'django.contrib.auth.middleware.AuthenticationMiddleware',     'django.contrib.messages.middleware.MessageMiddleware',     'django.middleware.clickjacking.XFrameOptionsMiddleware', ]  REST_FRAMEWORK = {     'DEFAULT_AUTHENTICATION_CLASSES': (         'oauth2_provider.contrib.rest_framework.OAuth2Authentication',     ),     'DEFAULT_PERMISSION_CLASSES': (         'rest_framework.permissions.IsAuthenticated',     ), }  ROOT_URLCONF = 'mausoleum_server.urls'  TEMPLATES = [     {         'BACKEND': 'django.template.backends.django.DjangoTemplates',         'DIRS': [],         'APP_DIRS': True,         'OPTIONS': {             'context_processors': [                 'django.template.context_processors.request',                 'django.contrib.auth.context_processors.auth',                 'django.contrib.messages.context_processors.messages',                 'social_django.context_processors.backends',                 'social_django.context_processors.login_redirect',             ],         },     }, ]  WSGI_APPLICATION = 'mausoleum_server.wsgi.application'   # Database # https://docs.djangoproject.com/en/5.2/ref/settings/#databases  DATABASES = {     'default': {         'ENGINE': 'django.db.backends.mysql',         'NAME': 'vr_mausoleum',         'USER': 'root',  # Usualmente 'root' en desarrollo         'PASSWORD': '1234',         'HOST': 'localhost',  # O la IP de tu servidor MySQL         'PORT': '3306',     } }   # Password validation # https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators  AUTH_PASSWORD_VALIDATORS = [     {         'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',     },     {         'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',     },     {         'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',     },     {         'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',     }, ]  OAUTH2_PROVIDER = {     'ACCESS_TOKEN_EXPIRE_SECONDS': 36000,     # 'OAUTH2_BACKEND_CLASS': 'oauth2_provider.oauth2_backends.JSONOAuthLibCore',     'OAUTH2_BACKEND_CLASS': 'oauth2_provider.oauth2_backends.OAuthLibCore',     'SCOPES': {         'read': 'Read scope',         'write': 'Write scope',     },     # 'GRANT_TYPES': ['authorization_code', 'password', 'client_credentials', 'refresh_token'],     'OAUTH2_VALIDATOR_CLASS': 'api.oauth_validators.MyOAuth2Validator', }   MIDDLEWARE = [     'api.middleware.LogRequestBodyMiddleware',     'api.middleware.TokenDebugMiddleware',     # ... otras middlewares     'django.middleware.security.SecurityMiddleware',     'django.contrib.sessions.middleware.SessionMiddleware',     'django.middleware.common.CommonMiddleware',     # 'django.middleware.csrf.CsrfViewMiddleware',  <-- comenta esto     'django.contrib.auth.middleware.AuthenticationMiddleware',     'django.contrib.messages.middleware.MessageMiddleware',     'django.middleware.clickjacking.XFrameOptionsMiddleware',     'social_django.middleware.SocialAuthExceptionMiddleware', ]  # DEBUG para solventar problemas de autorización  LOGGING = {     'version': 1,     'disable_existing_loggers': False,     'handlers': {         'console':{'class': 'logging.StreamHandler'},     },     'loggers': {         'oauth2_provider': {             'handlers': ['console'],             'level': 'DEBUG',             'propagate': True,         },         'oauthlib': {             'handlers': ['console'],             'level': 'DEBUG',             'propagate': True,         }     }, }    # Internationalization # https://docs.djangoproject.com/en/5.2/topics/i18n/  LANGUAGE_CODE = 'en-us'  TIME_ZONE = 'UTC'  USE_I18N = True  USE_TZ = True   # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/5.2/howto/static-files/  STATIC_URL = 'static/'  # Default primary key field type # https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field  DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'  APPEND_SLASH = True  # O mantenlo así por defecto AUTH_USER_MODEL = 'api.User'  """ URL configuration for mausoleum_server project.  The `urlpatterns` list routes URLs to views. For more information please see:     https://docs.djangoproject.com/en/5.2/topics/http/urls/ Examples: Function views     1. Add an import:  from my_app import views     2. Add a URL to urlpatterns:  path('', views.home, name='home') Class-based views     1. Add an import:  from other_app.views import Home     2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home') Including another URLconf     1. Import the include() function: from django.urls import include, path     2. Add a URL to urlpatterns:  path('blog/', include('blog.urls')) """ from django.contrib import admin from django.urls import path, include  urlpatterns = [     path('admin/', admin.site.urls),     path('o/', include('oauth2_provider.urls', namespace='oauth2_provider')),     path('api/', include('api.urls')),     path('auth/', include('social_django.urls', namespace='social')), ]  """ WSGI config for mausoleum_server project.  It exposes the WSGI callable as a module-level variable named ``application``.  For more information on this file, see https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/ """  import os  from django.core.wsgi import get_wsgi_application  os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mausoleum_server.settings')  application = get_wsgi_application()    

Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\others\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\uploads\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\api\migrations\output.txt
# Generated by Django 5.2.1 on 2025-05-13 13:35  from django.db import migrations, models   class Migration(migrations.Migration):      initial = True      dependencies = [     ]      operations = [         migrations.CreateModel(             name='Deceased',             fields=[                 ('id_deceased', models.BigAutoField(primary_key=True, serialize=False)),                 ('name', models.CharField(max_length=100)),                 ('date_birth', models.DateTimeField()),                 ('date_death', models.DateTimeField()),                 ('description', models.CharField(max_length=100)),                 ('burial_place', models.CharField(max_length=100)),                 ('visualization_state', models.BooleanField()),                 ('visualization_code', models.CharField(max_length=100)),             ],             options={                 'db_table': 'TBL_DECEASED',                 'managed': False,             },         ),         migrations.CreateModel(             name='DeceasedImage',             fields=[                 ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),                 ('image_link', models.CharField(max_length=1000)),             ],             options={                 'db_table': 'TBL_DECEASED_IMAGE',                 'managed': False,             },         ),         migrations.CreateModel(             name='DeceasedVideo',             fields=[                 ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),                 ('video_link', models.CharField(max_length=1000)),             ],             options={                 'db_table': 'TBL_DECEASED_VIDEO',                 'managed': False,             },         ),         migrations.CreateModel(             name='Image',             fields=[                 ('id_image', models.BigAutoField(primary_key=True, serialize=False)),                 ('image_link', models.CharField(max_length=1000)),                 ('event_title', models.CharField(max_length=100)),                 ('description', models.CharField(max_length=100)),             ],             options={                 'db_table': 'TBL_IMAGE',                 'managed': False,             },         ),         migrations.CreateModel(             name='ImageMetadata',             fields=[                 ('id_metadata', models.BigAutoField(primary_key=True, serialize=False)),                 ('date_created', models.DateTimeField()),                 ('coordinates', models.CharField(max_length=100)),             ],             options={                 'db_table': 'TBL_IMAGE_METADATA',                 'managed': False,             },         ),         migrations.CreateModel(             name='Notification',             fields=[                 ('id_notification', models.BigAutoField(primary_key=True, serialize=False)),                 ('message', models.CharField(max_length=1000)),                 ('is_read', models.BooleanField(default=False)),                 ('creation_date', models.DateTimeField()),             ],             options={                 'db_table': 'TBL_NOTIFICATION',                 'managed': False,             },         ),         migrations.CreateModel(             name='QR',             fields=[                 ('id_qr', models.BigAutoField(primary_key=True, serialize=False)),                 ('qr_code', models.BigIntegerField(unique=True)),                 ('visualization_status', models.CharField(max_length=50)),                 ('generation_date', models.DateTimeField()),             ],             options={                 'db_table': 'TBL_QR',                 'managed': False,             },         ),         migrations.CreateModel(             name='Relation',             fields=[                 ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),             ],             options={                 'db_table': 'TBL_RELATION',                 'managed': False,             },         ),         migrations.CreateModel(             name='RelationshipType',             fields=[                 ('relationship', models.CharField(max_length=100, primary_key=True, serialize=False)),             ],             options={                 'db_table': 'TBL_RELATIONSHIP_TYPE',                 'managed': False,             },         ),         migrations.CreateModel(             name='Request',             fields=[                 ('id_request', models.BigAutoField(primary_key=True, serialize=False)),                 ('creation_date', models.DateField()),                 ('request_type', models.CharField(max_length=50)),                 ('request_status', models.CharField(max_length=50)),             ],             options={                 'db_table': 'TBL_REQUEST',                 'managed': False,             },         ),         migrations.CreateModel(             name='User',             fields=[                 ('id_user', models.BigAutoField(primary_key=True, serialize=False)),                 ('name', models.CharField(max_length=100)),                 ('email', models.CharField(max_length=100)),                 ('password', models.CharField(max_length=250)),             ],             options={                 'db_table': 'TBL_USER',                 'managed': False,             },         ),         migrations.CreateModel(             name='UserDeceased',             fields=[                 ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),                 ('date_relation', models.DateTimeField()),                 ('has_permission', models.BooleanField()),             ],             options={                 'db_table': 'TBL_USER_DECEASED',                 'managed': False,             },         ),         migrations.CreateModel(             name='Video',             fields=[                 ('id_video', models.BigAutoField(primary_key=True, serialize=False)),                 ('video_link', models.CharField(max_length=1000)),                 ('event_title', models.CharField(max_length=100)),                 ('description', models.CharField(max_length=100)),             ],             options={                 'db_table': 'TBL_VIDEO',                 'managed': False,             },         ),         migrations.CreateModel(             name='VideoMetadata',             fields=[                 ('id_metadata', models.BigAutoField(primary_key=True, serialize=False)),                 ('date_created', models.DateTimeField()),                 ('coordinates', models.CharField(max_length=100)),             ],             options={                 'db_table': 'TBL_VIDEO_METADATA',                 'managed': False,             },         ),     ]  # Generated by Django 5.2.1 on 2025-05-14 23:58  from django.db import migrations   class Migration(migrations.Migration):      dependencies = [         ('api', '0001_initial'),     ]      operations = [         migrations.AlterModelOptions(             name='user',             options={},         ),     ]  # Generated by Django 5.2.1 on 2025-05-15 00:02  from django.db import migrations, models   class Migration(migrations.Migration):      dependencies = [         ('api', '0002_alter_user_options'),         ('auth', '0012_alter_user_first_name_max_length'),     ]      operations = [         migrations.AddField(             model_name='user',             name='groups',             field=models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups'),         ),         migrations.AddField(             model_name='user',             name='is_active',             field=models.BooleanField(default=True),         ),         migrations.AddField(             model_name='user',             name='is_staff',             field=models.BooleanField(default=False),         ),         migrations.AddField(             model_name='user',             name='is_superuser',             field=models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status'),         ),         migrations.AddField(             model_name='user',             name='last_login',             field=models.DateTimeField(blank=True, null=True),         ),         migrations.AddField(             model_name='user',             name='user_permissions',             field=models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions'),         ),         migrations.AlterField(             model_name='user',             name='email',             field=models.EmailField(max_length=254, unique=True),         ),         migrations.AlterField(             model_name='user',             name='name',             field=models.CharField(blank=True, max_length=100),         ),         migrations.AlterField(             model_name='user',             name='password',             field=models.CharField(max_length=128, verbose_name='password'),         ),     ]  # Generated by Django 5.2.1 on 2025-05-15 01:11  from django.db import migrations, models   class Migration(migrations.Migration):      dependencies = [         ('api', '0003_user_groups_user_is_active_user_is_staff_and_more'),         ('auth', '0012_alter_user_first_name_max_length'),     ]      operations = [         migrations.AlterField(             model_name='user',             name='groups',             field=models.ManyToManyField(blank=True, help_text='Los grupos a los que pertenece el usuario.', related_name='api_user_set', to='auth.group', verbose_name='groups'),         ),         migrations.AlterField(             model_name='user',             name='user_permissions',             field=models.ManyToManyField(blank=True, help_text='Permisos específicos para este usuario.', related_name='api_user_set', to='auth.permission', verbose_name='user permissions'),         ),     ]  # Generated by Django 5.2.1 on 2025-05-16 20:36  from django.db import migrations   class Migration(migrations.Migration):      dependencies = [         ('api', '0004_alter_user_groups_alter_user_user_permissions'),     ]      operations = [         migrations.AlterModelOptions(             name='user',             options={'managed': False},         ),     ]    

Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\api\__pycache__\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\api\migrations\__pycache__\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\mausoleum_server\__pycache__\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\others\Postman\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\others\SQL\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\uploads\images\output.txt


Contenido de: C:\Users\Tu\Downloads\AppServer4\AppServer\uploads\videos\output.txt



